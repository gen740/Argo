module;

export module Argo;
import std_module;

export import :Exceptions;
export import :Validation;
export import :Initializer;
export import :NArgs;

import :TypeTraits;
import :MetaAssigner;
import :MetaChecker;
import :MetaLookup;
import :Arg;

namespace Argo {

/*!
 * convert const char[] to std::array<char, N>
 */
export template <std::size_t N>
consteval auto arg(const char (&a)[N]) {
  std::array<char, N - 1> arr{};
  for (std::size_t i = 0; i < N - 1; ++i) {
    arr[i] = a[i];
  }
  return arr;
}

export template <int ID = 0, class Args = std::tuple<>>
class Parser {
 private:
  bool parsed_ = false;

 public:
  using Arguments = Args;
  Args value;

  template <class Type, auto Name, char ShortName = NULLCHAR, class... T>
    requires(Argo::SearchIndex<Arguments, Name>::value == -1 and
             (ShortName == NULLCHAR or
              Argo::SearchIndexFromShortName<Arguments, ShortName>::value == -1))
  auto addArg(T... args) {
    Initializer<Type, Name, ShortName, ID>::init(std::forward<T>(args)...);
    return Parser<ID, decltype(std::tuple_cat(                                        //
                          std::declval<Arguments>(),                                  //
                          std::declval<std::tuple<Arg<Type, Name, ShortName, ID>>>()  //
                          ))>();
  }

  template <auto Name, char ShortName = NULLCHAR, class... T>
    requires(Argo::SearchIndex<Arguments, Name>::value == -1 and
             (ShortName == NULLCHAR or
              Argo::SearchIndexFromShortName<Arguments, ShortName>::value == -1))
  auto addFlag(T... args) {
    Arg<bool, Name, ShortName, ID>::value = false;
    Arg<bool, Name, ShortName, ID>::flagArg = true;
    Initializer<bool, Name, ShortName, ID>::init(std::forward<T>(args)...);
    return Parser<ID, decltype(std::tuple_cat(                                      //
                          std::declval<Arguments>(),                                //
                          std::declval<std::tuple<FlagArg<Name, ShortName, ID>>>()  //
                          ))>();
  }

  template <auto Name>
  auto getArg() {
    if (!this->parsed_) {
      throw ParseError("Parser did not parse argument, call parse first");
    }
    using P =
        std::remove_cvref_t<decltype(std::get<SearchIndex<Arguments, Name>::value>(this->value))>;
    return P::value;
  }

  template <auto Name>
  auto getArgOr(std::remove_cvref_t<decltype(std::get<SearchIndex<Arguments, Name>::value>(
                    std::declval<Arguments>))>::type val) {
    return this->getArg<Name>.value_or(val);
  }

 private:
  /*!
   * Setting the argument value
   */
  auto setArg(std::string_view key, std::string_view val) {
    Assigner::assign<Arguments>(key, val);
  }

 public:
  /*!
   * Parse State
   */
  enum class ArgumentParseState {
    ExpectValue,
    ExpectArg,
    // ExpectOneValueOrFlag,
    // ExpectNValue,
    // Expect,
    // Expect,
  };

  /*!
   * Parse function
   */
  auto parse([[maybe_unused]] int argc, [[maybe_unused]] char* argv[]) -> void {
    auto parseState = ArgumentParseState::ExpectArg;
    std::string_view argBuffer;
    NArgs nargs('?');
    for (int i = 1; i < argc; i++) {
      auto argValue = std::string_view(argv[i]);
      switch (parseState) {
        case ArgumentParseState::ExpectArg:
          if (argValue.starts_with("--")) {
            if (argValue.contains("=")) {  // equal assign
              auto find_pos = argValue.find('=');
              this->setArg(argValue.substr(2, find_pos - 2), argValue.substr(find_pos + 1));
              break;
            }
            argBuffer = argValue.substr(2);
            auto check = Checker::check<Arguments>(argBuffer);
            nargs = check.nargs;

            if (check.isBool && check.isFlag) {
              this->setArg(argBuffer, "true");
              break;
            }
          } else if (argValue.starts_with('-')) {
            auto shortArg = argValue.substr(1);
            argBuffer = "";
            for (char i : shortArg) {
              auto optionName = GetNameFromShortName<Arguments>::eval(i);
              auto check = Checker::check<Arguments>(optionName);
              nargs = check.nargs;

              if (check.isBool && check.isFlag) {
                this->setArg(optionName, "true");
              } else {
                if (!argBuffer.empty()) {
                  throw Argo::InvalidArgument("Combining two more optional argument");
                }
                argBuffer = std::string(optionName);  // copy
              }
            }
            if (argBuffer.empty()) {
              break;
            }
          } else {
            throw Argo::InvalidArgument("Expect flag");
          }
          parseState = ArgumentParseState::ExpectValue;
          break;
        case ArgumentParseState::ExpectValue:
          if (argValue.starts_with('-')) {
            throw Argo::InvalidArgument("Expect value");
          }
          this->setArg(argBuffer, argValue);
          argBuffer = "";
          parseState = ArgumentParseState::ExpectArg;
          break;
      }
    }
    this->parsed_ = true;
  }
};

}  // namespace Argo

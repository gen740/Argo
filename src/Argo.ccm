module;

export module Argo;
import std_module;

export import :Exception;

import :TypeTraits;

namespace Argo {

constexpr char NULLCHAR = '\0';

/*!
 * Arg type this holds argument value
 */
template <class Type, auto Name, char ShortName = NULLCHAR>
struct Arg {
  static constexpr auto name = Name;
  using type = Type;
  inline static type value = {};
  inline static std::string_view description;
};

template <auto Name, char ShortName>
struct Arg<bool, Name, ShortName> {
  static constexpr auto name = Name;
  using type = bool;
  inline static bool value = {};
  inline static std::string_view description;
  inline static bool flagArg{};
};

/*!
 * convert const char[] to std::array<char, N>
 */
export template <std::size_t N>
consteval auto arg(const char (&a)[N]) {
  std::array<char, N - 1> arr{};
  for (std::size_t i = 0; i < N - 1; ++i) {
    arr[i] = a[i];
  }
  return arr;
}

export template <class Args = std::tuple<>>
class Parser {
 private:
  bool parsed_ = false;

 public:
  using Arguments = Args;
  Args value;

  template <class Type, auto Name, char ShortName = NULLCHAR>
  auto addArg(Type default_value = {}) {
    Arg<Type, Name, ShortName>::value = default_value;
    return Parser<decltype(std::tuple_cat(                      //
        std::declval<Arguments>(),                              //
        std::declval<std::tuple<Arg<Type, Name, ShortName>>>()  //
        ))>();
  }

  template <auto Name, char ShortName = NULLCHAR>
  auto addFlag() {
    Arg<bool, Name, ShortName>::value = false;
    Arg<bool, Name, ShortName>::flagArg = true;
    return Parser<decltype(std::tuple_cat(                      //
        std::declval<Arguments>(),                              //
        std::declval<std::tuple<Arg<bool, Name, ShortName>>>()  //
        ))>();
  }

  template <auto Name>
  auto getArg() {
    if (!this->parsed_) {
      throw ParseError("Parser did not parse argument, call parse first");
    }
    using P =
        std::remove_cvref_t<decltype(std::get<SearchIndex<Arguments, Name>::value>(this->value))>;
    return P::value;
  }

 private:
  /*!
   * Setting the argument value
   */
  auto setArg(std::string_view key, std::string_view val) {
    Assigner::assign<Arguments>(key, val);
  }

 public:
  /*!
   * Parse State
   */
  enum class ArgumentParseState {
    ExpectValue,
    ExpectArg,
    ParsedBoolFlag,
  };

  /*!
   * Parse function
   */
  auto parse([[maybe_unused]] int argc, [[maybe_unused]] char* argv[]) -> void {
    auto parseState = ArgumentParseState::ExpectArg;
    std::string_view argBuffer;
    for (int i = 1; i < argc; i++) {
      auto argValue = std::string_view(argv[i]);
      switch (parseState) {
        case ArgumentParseState::ParsedBoolFlag:
          if (argValue.contains("--")) {
            parseState = ArgumentParseState::ExpectArg;
            this->setArg(argBuffer, "true");
          } else {
            goto caseExpectValue;
          }
        case ArgumentParseState::ExpectArg:
          if (argValue.contains("--") && argValue.find("--") == 0) {
            if (argValue.contains("=")) {
              auto find_pos = argValue.find('=');
              this->setArg(argValue.substr(2, find_pos - 2), argValue.substr(find_pos + 1));
              break;
            }
            argBuffer = argValue.substr(2);

            if (TypeChecker<bool>::check<Arguments>(argBuffer)) {
              parseState = ArgumentParseState::ParsedBoolFlag;
              break;
            }

          } else {
            throw Argo::InvalidArgument("Expect flag");
          }
          parseState = ArgumentParseState::ExpectValue;
          break;
        caseExpectValue:
        case ArgumentParseState::ExpectValue:
          this->setArg(argBuffer, argValue);
          parseState = ArgumentParseState::ExpectArg;
          break;
      }
    }
    this->parsed_ = true;
  }
};

}  // namespace Argo
